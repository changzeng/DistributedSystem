// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <vector>
#include "ParameterServer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using std::endl;
using std::cout;
using std::vector;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class ParameterServerHandler : virtual public ParameterServerIf {
private:
    bool start_flag=false, finish_flag=false;
    int worker_num, cur_version=0, max_delta_num, max_version_diff;
    int cur_delta_num, cur_split_ind=-1, data_shard_size;
    vector<float> parameters;
    DataSet total_dataset;
    DeltaW tmp_delta;
public:
    ParameterServerHandler(int worker_num=10, int max_delta_num=2, int max_version_diff=5){
        this->worker_num=worker_num;
        this->max_delta_num=max_delta_num;
        this->cur_delta_num=0;
        this->max_version_diff=max_version_diff;
    }

    void push_delta(const DeltaW& delta) {
        if(cur_version-delta.version<=max_version_diff){
            ++cur_delta_num;
            if(cur_delta_num==1){
                tmp_delta.parameters.resize(delta.parameters.size());
                for(int i=0; i<(int)delta.parameters.size(); i++) tmp_delta.parameters[i]=0.0;
            }
            for(int i=0; i<tmp_delta.parameters.size(); i++) tmp_delta.parameters[i]+=delta.parameters[i];
            if(cur_delta_num>=max_delta_num){
                for(int i=0; i<tmp_delta.parameters.size(); i++) tmp_delta.parameters[i]/=(double)max_delta_num;
                cur_delta_num=0;
            }
        }
    }

    void pull_parameters(DeltaW& _return) {
        if(finish_flag) return;
        _return.parameters.resize(parameters.size());
        for(int i=0; i<(int)parameters.size(); i++) _return.parameters[i]=parameters[i];
        _return.version=cur_version;
    }

    void pull_dataset(DataSet& _return){
        _return.sample_list.reserve(data_shard_size);
        _return.labels.reserve(data_shard_size);
        for(int i=0; i<data_shard_size; i++){
            if(total_dataset.sample_list.size()<=0) break;
            _return.sample_list.push_back(total_dataset.sample_list.back());
            _return.labels.push_back(total_dataset.labels.back());
            total_dataset.sample_list.pop_back();
            total_dataset.labels.pop_back();
        }
    }

    bool connect_to_master(const HostInfo& host_info) {
        ++worker_num;
    }

    bool is_finish() {
        return finish_flag;
    }

    bool push_dataset(const DataSet& dataset) {
        if(start_flag){
            cout<<"Training process has been started. Can not commit data."<<endl;
            return false;
        }
        cout<<"Starting push dataset..."<<endl;
        for(const auto& sample:dataset.sample_list) total_dataset.sample_list.push_back(sample);
        for(const auto& label:dataset.labels) total_dataset.labels.push_back(label);
        start_flag=true;
        cout<<"Dataset transfer complete. Total dataset size is: "<<total_dataset.sample_list.size()<<endl;
        return true;
    }
};

int main(int argc, char **argv) {
    int port = 9090;
    ::apache::thrift::stdcxx::shared_ptr<ParameterServerHandler> handler(new ParameterServerHandler());
    ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new ParameterServerProcessor(handler));
    ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}

